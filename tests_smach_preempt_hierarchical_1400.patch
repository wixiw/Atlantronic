Index: arp_master/src/arp_master/fsmFramework/PreemptiveStateMachine.py
===================================================================
--- arp_master/src/arp_master/fsmFramework/PreemptiveStateMachine.py	(revision 1400)
+++ arp_master/src/arp_master/fsmFramework/PreemptiveStateMachine.py	(working copy)
@@ -14,7 +14,7 @@
 # this PreemptiveStateMachine will register the preemptive state within the normal states, so that preemptive states call their preemption function
 class PreemptiveStateMachine(smach.StateMachine):
     def __init__(self,outcomes):
-        self.preemptiveStates=[]
+        self.preemptiveStates={}
         smach.StateMachine.__init__(self,outcomes=outcomes)
     
     #use this function to add a preemptive state
@@ -23,7 +23,10 @@
         #je trouve cette implementation ridicule (cf ligne suivante). faut croire que c'est a cause du "with"
         #que add est une fonction static
         self=PreemptiveStateMachine._currently_opened_container()
-        self.preemptiveStates.append([label,state])
+        self.preemptiveStates[label]=state
+        rospy.logerr("bonjour et bienvenu dans ADD PRREEMPTIVE de je sais pas qui")
+        rospy.logerr("preemptive states a moi apres ajout:")
+        rospy.logerr(str(self.preemptiveStates))
         smach.StateMachine.add(label,state,transitions=transitions,remapping=remapping)
         
     #use this function to add a normal state
@@ -31,16 +34,31 @@
     def add(label,state,transitions=None,remapping=None):
         self=PreemptiveStateMachine._currently_opened_container()
         #register preemptive states
-        state.preemptiveStates=self.preemptiveStates
+        rospy.logerr("bonjour et bienvenu dans ADD normal de je sais pas qui. ajout de")
+        rospy.logerr(label)
+        rospy.logerr("a qui je passe mes preemptives states:")
+        rospy.logerr(self.preemptiveStates)
+        
+        state.registerPreemptiveState(self.preemptiveStates)
+
         #extend the transitions ("auto transitions")
-        for p in self.preemptiveStates:
-            # I add a transition "preemptiveStatename" going into "preemtivestatename"
-            transitions[p[0]]=p[0]
-            # I must add this outcome to the state. initial outcomes were created by at initialisation of state
-            state._outcomes.add(p[0])
+        for plabel,pstate in self.preemptiveStates.iteritems():
+            # I add a transition "preemptiveStatename" going into "preemptivestatename"
+            transitions[plabel]=plabel
+
         #now I call the usual add function
         smach.StateMachine.add(label,state,transitions=transitions,remapping=remapping)
     
+    def registerPreemptiveState(self,preemptiveStates):
+        rospy.logerr("bonjour et bienvenu dans register de je sais pas qui. ajout de")
+        rospy.logerr(preemptiveStates)
+        self.preemptiveStates=preemptiveStates
+        for plabel,pstate in self.preemptiveStates.iteritems():
+            self._outcomes.add(plabel)
+        # i ask it to my children
+        for clabel,cstate in self._states.iteritems() :
+            cstate.registerPreemptiveState(preemptiveStates)
+    
     def setInitialState(self,label):
         self._initial_state_label=label
     
Index: arp_master/src/arp_master/fsmFramework/CyclicState.py
===================================================================
--- arp_master/src/arp_master/fsmFramework/CyclicState.py	(revision 1400)
+++ arp_master/src/arp_master/fsmFramework/CyclicState.py	(working copy)
@@ -7,7 +7,7 @@
 import smach_ros
 import smach_msgs
 
-
+from PreemptiveStateMachine import *
 from arp_master.util.Inputs import Inputs
 from arp_master.util.Data import Data
 
@@ -22,10 +22,10 @@
 # the cyclic state also implements all interfaces with outside of arp_master
 # the cyclic state may have an internal timer that fires a timeout transition to prevent being stalled (timeout in seconds)
 
-class CyclicState(smach.StateMachine):
+class CyclicState(PreemptiveStateMachine):
     def __init__(self,outcomes):
         outcomes.append('timeout')
-        smach.StateMachine.__init__(self,outcomes)
+        PreemptiveStateMachine.__init__(self,outcomes)
         self.preemptiveStates=[]
         self.initClients()
         self.timeout=0
Index: arp_master/src/arp_master/fsmFramework/CyclicActionState.py
===================================================================
--- arp_master/src/arp_master/fsmFramework/CyclicActionState.py	(revision 1401)
+++ arp_master/src/arp_master/fsmFramework/CyclicActionState.py	(working copy)
@@ -24,7 +24,7 @@
         except KeyError:
             rospy.logerr("Failed to find a rosparam : /blinding_period") 
             self.blinding_period=0
-   
+    
     
     # the main execute function
     #it overrides the one of CyclicState
@@ -32,6 +32,7 @@
     def execute(self,userdata):
         self.timeIn=rospy.get_rostime().secs
         Inputs.update()
+        self.executeIn()
         self.actionCreated = False
         #this should always be overrided !
         self.createAction()
Index: arp_master/src/arp_master/strat_2012/common_2012/TotemStates.py
===================================================================
--- arp_master/src/arp_master/strat_2012/common_2012/TotemStates.py	(revision 1400)
+++ arp_master/src/arp_master/strat_2012/common_2012/TotemStates.py	(working copy)
@@ -14,11 +14,13 @@
 class CleanCloseTotem(PreemptiveStateMachine):
     def __init__(self, table_half):
         PreemptiveStateMachine.__init__(self,outcomes=['endClean','problem'])
-        with self:      
-            PreemptiveStateMachine.addPreemptive('EndMatchPreemption',
+        with self: 
+            rospy.logerr("j'ajoute EndMatchPreemption dans CleanCloseTotem")     
+            PreemptiveStateMachine.addPreemptive('EndMatchPreemptionCleanTotem',
                                              EndMatchPreempter(-5.0),
                                              transitions={'endMatch':'endClean'})
-                                       
+            
+            rospy.logerr("j'ajoute OpenFinger dans CleanCloseTotem")             
             PreemptiveStateMachine.add('OpenFinger',
                       FingersOnlyState('open'), 
                       transitions={'succeeded':'SetVmax', 'timeout':'GotoFirstTotemCoin'})
Index: arp_master/src/arp_master/strat_2012/common_2012/Table2012.py
===================================================================
--- arp_master/src/arp_master/strat_2012/common_2012/Table2012.py	(revision 1400)
+++ arp_master/src/arp_master/strat_2012/common_2012/Table2012.py	(working copy)
@@ -4,7 +4,7 @@
 
 import rospy
 import smach
-
+from arp_master import *
 from arp_master.util.Data import *
 
 #il faut voir ca comme un namespace
@@ -89,13 +89,13 @@
             
             
 # Use this state to define a variable 
-class SetStratInfoState(smach.State):
+class SetStratInfoState(CyclicState):
     def __init__(self, strat_info,value):
+        CyclicState.__init__(self,['ok'])
         self.strat_info = strat_info
         self.value = value
-        smach.State.__init__(self,['ok'])
-    def execute(self,userdata):
-        
+     
+    def executeIn(self):
         rospy.loginfo("SetStratInfoState : %s is set to %s (time=%s)", 
                       self.strat_info, self.value, (rospy.get_rostime()-Data.start_time).to_sec())
         
@@ -132,7 +132,8 @@
             Table2012.botFarTotemFull = self.value
         else:
             rospy.logerr("SetStratInfoState : default case : strat info (%s)  not known !!", self.strat_info)
-                           
+            
+    def executeTransitions(self):                   
         return 'ok'
     
     
Index: arp_master/src/arp_master/strat_2012/homologation/a2_opening/Strat_Opening.py
===================================================================
--- arp_master/src/arp_master/strat_2012/homologation/a2_opening/Strat_Opening.py	(revision 1400)
+++ arp_master/src/arp_master/strat_2012/homologation/a2_opening/Strat_Opening.py	(working copy)
@@ -9,7 +9,8 @@
     def __init__(self):
         PreemptiveStateMachine.__init__(self, outcomes=['endOpening', 'problem'])
         with self:
-            PreemptiveStateMachine.addPreemptive('EndMatchPreemption',
+            rospy.logerr("j'ajoute EndMatchPreemption dans Opening")
+            PreemptiveStateMachine.addPreemptive('EndMatchPreemptionOpening',
                                              EndMatchPreempter(-5.0),
                                              transitions={'endMatch':'problem'})
             
@@ -19,19 +20,23 @@
 #                      transitions={'succeeded':'problem', 'timeout':'problem'})
 #            self.setInitialState('SweepSweep')
 
+            rospy.logerr("j'ajoute OpenLeftFinger dans Opening")
             PreemptiveStateMachine.add('OpenLeftFinger',
                       FingersOnlyState('open_left'), 
                       transitions={'succeeded':'GotoTopCloseCoin', 'timeout':'GotoTopCloseCoin'})
             self.setInitialState('OpenLeftFinger')
             
+            rospy.logerr("j'ajoute GotoTopCloseCoin dans Opening")
             PreemptiveStateMachine.add('GotoTopCloseCoin',
                       AmbiOmniDirectOrder(0.100, 0.600,-pi/2),
                       transitions={'succeeded':'SetStratInfo', 'timeout':'SetStratInfo'})
             
+            rospy.logerr("j'ajoute SetStratInfo dans Opening")
             PreemptiveStateMachine.add('SetStratInfo',
                       SetStratInfoState('topCloseCoinInPosition', False),
                       transitions={'ok':'CleanTopCloseTotem'})
              
+            rospy.logerr("j'ajoute CleanTopCloseTotem dans Opening")
             PreemptiveStateMachine.add('CleanTopCloseTotem',
                       CleanTopCloseTotem(),
                       transitions={'endClean':'endOpening', 'problem':'Debloque'})
