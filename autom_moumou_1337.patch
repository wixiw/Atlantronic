Index: arp_ods/src/control/orders/OmnidirectOrder.hpp
===================================================================
--- arp_ods/src/control/orders/OmnidirectOrder.hpp	(revision 1337)
+++ arp_ods/src/control/orders/OmnidirectOrder.hpp	(working copy)
@@ -81,6 +81,7 @@
         static const double TIMELAG=0.030;
         static const double DIST_SMOOTH=0.050;
         static const double SUP_TIME_FOR_ROTATION=1.0;
+        static const double K_THETA=3.0;
 
 
 private:
Index: arp_ods/src/control/orders/OmnidirectOrder.cpp
===================================================================
--- arp_ods/src/control/orders/OmnidirectOrder.cpp	(revision 1336)
+++ arp_ods/src/control/orders/OmnidirectOrder.cpp	(working copy)
@@ -73,13 +73,13 @@
         // si j'entre directement en approche, il faut que je calcule un twist initial
 
         //TODO on peut pas faire plus dégueu, comme j'ai pas dt je le force.
-        m_twist_approach = computeRunTwist(currentPosition,0.02);
+        m_twist_approach = computeRunTwist(currentPosition, 0.02);
 
-        m_error_approach=getPositionError_RobotRef(currentPosition);
-        m_pose_approach=currentPosition;
+        m_error_approach = getPositionError_RobotRef(currentPosition);
+        m_pose_approach = currentPosition;
         //to initialize the error
-        computeApproachTwist(currentPosition,0.02);
-        m_normalizedError_old=m_normalizedError+1.0;//+1 to be sure that the first comparison will be ok
+        computeApproachTwist(currentPosition, 0.02);
+        m_normalizedError_old = m_normalizedError + 1.0; //+1 to be sure that the first comparison will be ok
 
         Log(DEBUG) << "m_twist_approach" << m_twist_approach.toString();
         Log(DEBUG) << "m_error_approach" << m_error_approach.toString();
@@ -88,7 +88,6 @@
 
     testTimeout();
 
-
 }
 
 void OmnidirectOrder::switchApproach(arp_math::Pose2D currentPosition)
@@ -106,10 +105,9 @@
      m_runTime = getTime();
      }*/
 
-    if (m_normalizedError_old<=m_normalizedError)
+    if (m_normalizedError_old <= m_normalizedError)
     {
-        Log(INFO) << getTypeString() << " switched MODE_APPROACH --> MODE_DONE "
-                << "because error began to increase";
+        Log(INFO) << getTypeString() << " switched MODE_APPROACH --> MODE_DONE " << "because error began to increase";
         Log(INFO) << "robot position  " << currentPosition.toString();
         Log(INFO) << "cpoint position " << current_cpoint_position.toString();
         Log(INFO) << "aim position    " << m_endPose.toString();
@@ -119,7 +117,7 @@
         m_currentMode = MODE_DONE;
         return;
     }
-    m_normalizedError_old=m_normalizedError;
+    m_normalizedError_old = m_normalizedError;
 
     testTimeout();
 
@@ -163,49 +161,40 @@
     // a = 2 * d / t²
     // t² = time for rotation + additional time
     // time for rotation = sqrt( 2 * d_rot / a_rot )
-    double time_for_rotation=SUP_TIME_FOR_ROTATION+sqrt( 2 * fabs(deltaPos_refCpoint.h()) / m_conf.ANG_DEC );
-    double reduced_LIN_DEC=2*deltaPos_refCpoint.vectNorm()/(time_for_rotation*time_for_rotation);
-    double LIN_DEC=min(reduced_LIN_DEC,m_conf.LIN_DEC);
+    double time_for_rotation = SUP_TIME_FOR_ROTATION + sqrt(2 * fabs(deltaPos_refCpoint.h()) / m_conf.ANG_DEC);
+    double reduced_LIN_DEC = 2 * deltaPos_refCpoint.vectNorm() / (time_for_rotation * time_for_rotation);
+    double LIN_DEC = min(reduced_LIN_DEC, m_conf.LIN_DEC);
 
     // brutal correction twist. with constant acceleration   v = sqrt ( 2 . acc) . sqrt( d )
     Twist2D v_correction_cpoint;
     double speedcorrection = sqrt2(2.0 * LIN_DEC)
             * sqrt2(max(deltaPos_refCpoint.vectNorm() - m_v_correction_old.speedNorm() * TIMELAG, 0.0));
 
-    // pour l'avance de phase sur l'angle, je met une zone morte pour l'empecher d'osciller.
-    double distance_ang=deltaPos_refCpoint.h();
-    double distance_ang_avance=deltaPos_refCpoint.h() - m_v_correction_old.vh()* TIMELAG;
-    double distance_ang_avance_sat;
-    /*
-    if (sign(distance_ang)==sign(distance_ang_avance))
-        distance_ang_avance_sat=distance_ang_avance;
-    else
-        distance_ang_avance_sat=0;
-*/
-    distance_ang_avance_sat=distance_ang_avance ;
-
-    //correction en angle, la meme que pour la vitesse
-    double angcorrection = sqrt2(2.0 * m_conf.ANG_DEC)
-            * sqrt2(distance_ang_avance_sat);
+    //correction en angle,  attention la racine rend le robot instable en ligne droite. (trop de correction sur les petits theta)
+    double distance_ang_avance = deltaPos_refCpoint.h() - m_v_correction_old.vh() * TIMELAG;
+    double angcorrection = K_THETA * distance_ang_avance;
     /*if (m_error_old==Pose2D(0,0,0)) // first turn ?
-        m_error_old=deltaPos_refCpoint;
-    double error_derivative=betweenMinusPiAndPlusPi(deltaPos_refCpoint.h()-m_error_old.h())/dt;
-    double angcorrection = sqrt2(2.0 * m_conf.ANG_DEC)* sqrt2(deltaPos_refCpoint.h())+error_derivative*K_D;*/
-    v_correction_cpoint.vx(speedcorrection * std::cos(deltaPos_refCpoint.vectAngle()));
-    v_correction_cpoint.vy(speedcorrection * std::sin(deltaPos_refCpoint.vectAngle()));
+     m_error_old=deltaPos_refCpoint;
+     double error_derivative=betweenMinusPiAndPlusPi(deltaPos_refCpoint.h()-m_error_old.h())/dt;
+     double angcorrection = sqrt2(2.0 * m_conf.ANG_DEC)* sqrt2(deltaPos_refCpoint.h())+error_derivative*K_D;*/
+
+    //essayé de mettre de l'avance de phase sur la correction en speedAngle, puisque le theta point a un effet sur elle. pas réussi a faire marcher
+    double speedAngle=deltaPos_refCpoint.vectAngle()+angcorrection* 0.0;
+    v_correction_cpoint.vx(speedcorrection * std::cos(speedAngle));
+    v_correction_cpoint.vy(speedcorrection * std::sin(speedAngle));
     v_correction_cpoint.vh(angcorrection);
 
-/*
-    Log(DEBUG) << "----";
-    Log(DEBUG) << "deltaPos_refCpoint.h() " << deltaPos_refCpoint.h();
-    Log(DEBUG) << "m_error_old.h() " << m_error_old.h();
-    Log(DEBUG) << "error_derivative " << error_derivative;
-    Log(DEBUG) << "racine truc " << sqrt2(2.0 * m_conf.ANG_DEC)* sqrt2(deltaPos_refCpoint.h());
-    Log(DEBUG) << "angcorrection " << angcorrection;
-    Log(DEBUG) << "----";
-*/
+    /*
+     Log(DEBUG) << "----";
+     Log(DEBUG) << "deltaPos_refCpoint.h() " << deltaPos_refCpoint.h();
+     Log(DEBUG) << "m_error_old.h() " << m_error_old.h();
+     Log(DEBUG) << "error_derivative " << error_derivative;
+     Log(DEBUG) << "racine truc " << sqrt2(2.0 * m_conf.ANG_DEC)* sqrt2(deltaPos_refCpoint.h());
+     Log(DEBUG) << "angcorrection " << angcorrection;
+     Log(DEBUG) << "----";
+     */
 
-    m_error_old=deltaPos_refCpoint;
+    m_error_old = deltaPos_refCpoint;
 
     outDEBUGLinSpeedCorrection = speedcorrection;
     outDEBUGAngSpeedCorrection = angcorrection;
@@ -220,31 +209,31 @@
 
     Pose2D deltaPos_refCpoint = getPositionError_RobotRef(currentPosition);
     // this is the current % of the initial error when I entered the approach zone
-    m_normalizedError=getTotalError(deltaPos_refCpoint)/getTotalError(m_error_approach);
+    m_normalizedError = getTotalError(deltaPos_refCpoint) / getTotalError(m_error_approach);
 
-    outDEBUGNormalizedError=m_normalizedError;
-    outDEBUGErrorApproachInit=getTotalError(m_error_approach);
-    outDEBUGErrorApproachCur=getTotalError(deltaPos_refCpoint);
+    outDEBUGNormalizedError = m_normalizedError;
+    outDEBUGErrorApproachInit = getTotalError(m_error_approach);
+    outDEBUGErrorApproachCur = getTotalError(deltaPos_refCpoint);
 
-    Log(DEBUG) << ">>computeApproachTwist  " ;
-    Log(DEBUG) << "current error  "<<deltaPos_refCpoint.toString() ;
-    Log(DEBUG) << "current error norm  " <<getTotalError(deltaPos_refCpoint);
-    Log(DEBUG) << "initial error  " <<m_error_approach.toString();
-    Log(DEBUG) << "initial error norm  "<< getTotalError(m_error_approach);
+    /*
+    Log(DEBUG) << ">>computeApproachTwist  ";
+    Log(DEBUG) << "current error  " << deltaPos_refCpoint.toString();
+    Log(DEBUG) << "current error norm  " << getTotalError(deltaPos_refCpoint);
+    Log(DEBUG) << "initial error  " << m_error_approach.toString();
+    Log(DEBUG) << "initial error norm  " << getTotalError(m_error_approach);
     Log(DEBUG) << "normalize error  " << m_normalizedError;
 
-    Log(DEBUG) << "m_twist_approach"<< m_twist_approach.toString() ;
-    Log(DEBUG) << "twist applied"<< (m_twist_approach*sqrt2(m_normalizedError)).toString() ;
+    Log(DEBUG) << "m_twist_approach" << m_twist_approach.toString();
+    Log(DEBUG) << "twist applied" << (m_twist_approach * sqrt2(m_normalizedError)).toString();
     Log(DEBUG) << "<<computeApproachTwist  ";
-
+*/
     // je remet le twist approach dans le bon referentiel car mon robot a tourné depuis!
-    //Pose2D repere_rotation(0,0,currentPosition.angle()-m_pose_approach.angle());
-    //Twist2D m_twist_approach_turned=m_twist_approach.changeProjection(repere_rotation);
+    Pose2D repere_rotation(0, 0, currentPosition.angle() - m_pose_approach.angle());
+    Twist2D m_twist_approach_turned = m_twist_approach.changeProjection(repere_rotation);
 
-    //m_twist_approach_turned=m_twist_approach;
+    m_twist_approach_turned = m_twist_approach;
 
-    return m_twist_approach*sqrt2(m_normalizedError);
-
+    return m_twist_approach_turned * sqrt2(m_normalizedError);
 
 }
 
@@ -252,12 +241,17 @@
 {
     //is a smooth localization needed ?
     Pose2D deltaPos_refCpoint = getPositionError_RobotRef(currentPosition);
-    if(deltaPos_refCpoint.vectNorm() < DIST_SMOOTH)
+    if (deltaPos_refCpoint.vectNorm() < DIST_SMOOTH)
         m_smoothLocNeeded = true;
 
     else
         m_smoothLocNeeded = false;
 
+    if (m_smoothLocNeeded)
+        outDEBUGSmoothLocNeeded = 1.0;
+    else
+        outDEBUGSmoothLocNeeded = 0.0;
+
 }
 Twist2D OmnidirectOrder::computeSpeed(arp_math::Pose2D currentPosition, double dt)
 {
@@ -273,11 +267,11 @@
 
     if (m_currentMode == MODE_RUN)
     {
-    v_correction_ref = computeRunTwist(currentPosition,dt);
+        v_correction_ref = computeRunTwist(currentPosition, dt);
     }
     if (m_currentMode == MODE_APPROACH)
     {
-    v_correction_ref = computeApproachTwist(currentPosition,dt);
+        v_correction_ref = computeApproachTwist(currentPosition, dt);
     }
 
     //saturation of twist: limit max linear speed/acc;  and max rotation speed/acc
@@ -303,11 +297,12 @@
             saturated_linspeed * sin(twist_input.speedAngle()), saturated_angspeed);
 
     outDEBUGSaturation = saturated_angspeed;
+    outDEBUGSpeedAngle=twist_input.speedAngle();
 
     return twist_output;
 }
 
 double OmnidirectOrder::getTotalError(Pose2D pose)
 {
-return sqrt(pose.x()*pose.x()+pose.y()*pose.y()+0.2*0.2*pose.h()*pose.h());
+    return sqrt(pose.x() * pose.x() + pose.y() * pose.y() + 0.2 * 0.2 * pose.h() * pose.h());
 }
Index: arp_ods/src/control/orders/MotionOrder.cpp
===================================================================
--- arp_ods/src/control/orders/MotionOrder.cpp	(revision 1337)
+++ arp_ods/src/control/orders/MotionOrder.cpp	(working copy)
@@ -31,6 +31,8 @@
     m_openloop_duration=order.m_openloop_duration;
     m_smoothLocNeeded=false;
     m_error_old=Pose2D(0,0,0);
+
+    attrGain=0.03;
     //m_id != m_id !!
 }
 
Index: arp_ods/src/control/orders/MotionOrder.hpp
===================================================================
--- arp_ods/src/control/orders/MotionOrder.hpp	(revision 1337)
+++ arp_ods/src/control/orders/MotionOrder.hpp	(working copy)
@@ -97,6 +97,11 @@
         double outDEBUGErrorApproachInit;
         double outDEBUGErrorApproachCur;
 
+        double  outDEBUGSmoothLocNeeded;
+        double  outDEBUGSpeedAngle;
+
+        double attrGain;
+
         /**
          * is smooth localization needed ?
          */
Index: arp_ods/src/components/LittleSexControl.cpp
===================================================================
--- arp_ods/src/components/LittleSexControl.cpp	(revision 1337)
+++ arp_ods/src/components/LittleSexControl.cpp	(working copy)
@@ -68,6 +68,10 @@
         outDEBUGMode.write(attrOrder->getMode());
         outDEBUGErrorApproachInit.write(attrOrder->outDEBUGErrorApproachInit);
         outDEBUGErrorApproachCur.write(attrOrder->outDEBUGErrorApproachCur);
+        outDEBUGSmoothLocNeeded.write(attrOrder->outDEBUGSmoothLocNeeded);
+        outDEBUGSpeedAngle.write(attrOrder->outDEBUGSpeedAngle);
+
+        attrOrder->attrGain=attrGain;
     }
 
     if (attrOrder->getType()==OMNIDIRECT)
@@ -173,6 +177,8 @@
     addAttribute("attrCurrentOrder",attrCurrentOrder);
     addAttribute("attrCurrentTwist",attrCurrentTwist);
 
+    addAttribute("attrGain",attrGain);
+
     addPort("inPosition",inPosition)
         .doc("");
     addPort("inCurrentTwist",inCurrentTwist)
@@ -202,6 +208,14 @@
                  .doc("");
     addPort("outDEBUGErrorApproachCur",outDEBUGErrorApproachCur)
                  .doc("");
+    addPort("outDEBUGSmoothLocNeeded",outDEBUGSmoothLocNeeded)
+                 .doc("");
+    addPort("outDEBUGSpeedAngle",outDEBUGSpeedAngle)
+                 .doc("");
+
+
+
+
 
     addPort("outSmoothLocNeeded",outSmoothLocNeeded)
     .doc("MotionControl needs a localization with no steps");
Index: arp_ods/src/components/LittleSexControl.hpp
===================================================================
--- arp_ods/src/components/LittleSexControl.hpp	(revision 1337)
+++ arp_ods/src/components/LittleSexControl.hpp	(working copy)
@@ -81,6 +81,12 @@
         RTT::OutputPort<double>  outDEBUGErrorApproachInit;
         RTT::OutputPort<double>  outDEBUGErrorApproachCur;
 
+        RTT::OutputPort<double>  outDEBUGSmoothLocNeeded;
+        RTT::OutputPort<double>  outDEBUGSpeedAngle;
+
+        //DEBUG
+        double attrGain;
+
         /**
          * Buffer for computed speed commands
          */
